import $ from "jsr:@david/dax@0.43.2";
import { exists } from "jsr:@std/fs@1.0.19";
import { basename, join } from "jsr:@std/path@1.0.4";
import { chain, takeWhile } from "./lib/iterators.ts";
import { safeLinesFromFile } from "./lib/readables.ts";

function stripPrefix(input: string, prefix: string): string | null {
  return input.startsWith(prefix) ? input.slice(prefix.length) : null;
}

async function getCurrentGitHubRepo(): Promise<string | null> {
  const remoteUrl = await $`git remote get-url origin`.text();
  const match = remoteUrl.match(
    /https:\/\/github\.com\/(.+?)\/(?<repo>.+?)(?:\.git)?$/,
  );
  return match?.groups?.repo ?? null;
}

const SENTINEL_COMMENT = "# AUTOGENERATED - DO NOT EDIT BELOW THIS LINE";

async function* entriesFromFile(filename: string): AsyncGenerator<string> {
  let multiline = null;
  for await (const current of safeLinesFromFile(filename)) {
    if (multiline === null) {
      if (parseLine(current).value?.startsWith('"')) {
        multiline = current;
      } else {
        yield current;
      }
    } else {
      multiline += "\n" + current;

      if (current.endsWith('"')) {
        yield multiline;
        multiline = null;
      }
    }
  }
}

function parseLine(line: string): { key: string | null; value: string | null } {
  const trimmed = line.trim();
  if (trimmed.startsWith("#")) {
    return { key: null, value: null };
  }

  const splitIndex = trimmed.indexOf("=");
  if (splitIndex === -1) {
    return { key: null, value: null };
  }
  return {
    key: trimmed.slice(0, splitIndex),
    value: trimmed.slice(splitIndex + 1),
  };
}

interface File {
  source: string;
  name: string;
}

/**
 * Take the environment variables from the secrets files and merge them into the destination (the project's .env.local),
 * letting the destination take precedence.
 */
async function mergeEnvs(
  destination: string,
  secretsFiles: File[],
) {
  const overrideLines = await Array.fromAsync(
    takeWhile(
      entriesFromFile(destination),
      (line) => line !== SENTINEL_COMMENT,
    ),
  );

  if (secretsFiles.length === 0) {
    // Remove the sentinel comment but don't create the env file if it doesn't exist
    if (await exists(destination)) {
      await Deno.writeTextFile(destination, overrideLines.join("\n") + "\n");
    }
    return;
  }

  const overrides = new Set<string>();
  for (const line of overrideLines) {
    const { key } = parseLine(line);
    if (key) {
      overrides.add(key);
    }
  }

  const envLines = [...overrideLines, SENTINEL_COMMENT];
  for await (
    const line of chain(
      ...secretsFiles.map((file) => entriesFromFile(file.source)),
    )
  ) {
    const { key } = parseLine(line);
    if (key && overrides.has(key)) {
      envLines.push(`# ${line.replaceAll("\n", "\n# ")}`);
    } else {
      envLines.push(line);
    }
  }

  await Deno.writeTextFile(destination, envLines.join("\n") + "\n");
  console.log(
    `Synced ${secretsFiles.length} secrets file(s) to ${
      basename(destination)
    } [${secretsFiles.map((file) => file.name).join(", ")}]`,
  );
}

/**
 * Apply all changes to a specific git repo.
 */
async function setupRepo(
  repoDir: string,
  secretsFiles: File[],
  copiedFiles: File[],
) {
  console.group(`Setting up repo ${repoDir}`);

  for await (const { source, name } of copiedFiles) {
    console.log(`Synced ${name}`);
    await Deno.copyFile(source, join(repoDir, name));
  }

  await mergeEnvs(join(repoDir, ".env.local"), secretsFiles);

  const gitDir = await $`git rev-parse --git-common-dir`.text();
  const gitExcludePath = join(gitDir, "info", "exclude");
  const ignoredFiles = [
    ".env.local",
    ...copiedFiles.map((file) => file.name),
  ];
  await $`ensure-lines ${gitExcludePath}`.stdinText(ignoredFiles.join("\n"));
  console.log(
    `Ignored ${ignoredFiles.length} file(s) in git [${
      ignoredFiles.join(", ")
    }]`,
  );

  if (Deno.args.includes("--new")) {
    await $`mise trust --quiet`;
    const miseTasks = await $`mise task --local`.lines();
    if (miseTasks.includes("setup")) {
      await $`mise task run setup`.noThrow();
    }
  }

  console.groupEnd();
}

/**
 * Run generate-cached and return the filename of the generated data.
 */
function runGenerator(generatorScript: string): Promise<string> {
  const regenerate = Deno.args.includes("--regenerate");
  return $`~/dev/scripts/generate-cached.fish ${generatorScript} ${
    regenerate ? ["--regenerate"] : []
  }`.text();
}

async function main() {
  const repo = await getCurrentGitHubRepo();
  if (!repo) {
    console.error("No GitHub repository detected");
    Deno.exit(1);
  }

  const homeDir = Deno.env.get("HOME");
  if (!homeDir) {
    console.error("$HOME environment variable is not set");
    Deno.exit(1);
  }

  const envConfigDir = join(
    homeDir,
    ".config",
    "env",
    repo,
  );
  if (!(await exists(envConfigDir))) {
    console.error(`No env files found for ${repo}`);
    Deno.exit(1);
  }

  const secretsFiles: File[] = [];
  const copiedFiles: File[] = [];
  for await (const entry of Deno.readDir(envConfigDir)) {
    if (!entry.isFile) {
      continue;
    }

    const secretName = stripPrefix(entry.name, "secrets_");
    const name = secretName ?? entry.name;

    // Treat all executable files as generators, otherwise simply copy the file
    const stat = await Deno.stat(join(envConfigDir, entry.name));
    const executable = ((stat.mode ?? 0) & 0o100) !== 0;
    const source = executable
      ? await runGenerator(join(envConfigDir, entry.name))
      : join(envConfigDir, entry.name);
    const file = { source, name };

    if (secretName === null) {
      // secrets_$filename files and scripts are merged into .env.local instead of copied
      copiedFiles.push(file);
    } else {
      console.log(`Generated secrets from ${name}`);
      secretsFiles.push(file);
    }
  }

  if (Deno.args.includes("--all")) {
    // Apply changes to all worktrees
    const worktrees = (await $`git worktree list --porcelain`.lines())
      .map((line) => stripPrefix(line, "worktree "))
      .filter((line) => line !== null);
    console.log(`Setting up ${worktrees.length} worktrees`);
    for await (const worktree of worktrees) {
      await setupRepo(worktree, secretsFiles, copiedFiles);
    }
  } else {
    const repo = await $`git rev-parse --show-toplevel`.text();
    await setupRepo(repo, secretsFiles, copiedFiles);
  }
}

main();
