import $ from "jsr:@david/dax@0.43.2";
import { exists } from "jsr:@std/fs@1.0.19";
import { join } from "jsr:@std/path@1.0.4";
import { chain, filterMap, takeWhile } from "./lib/iterators.ts";
import { linesFromFile, safeLinesFromFile } from "./lib/readables.ts";

function stripPrefix(input: string, prefix: string): string | null {
  return input.startsWith(prefix) ? input.slice(prefix.length) : null;
}

interface GitHubRepo {
  owner: string;
  repo: string;
}
async function getCurrentGitHubRepo(): Promise<GitHubRepo | null> {
  const remoteUrl = await $`git remote get-url origin`.text();
  const match = remoteUrl.match(
    /https:\/\/github\.com\/(?<owner>.+?)\/(?<repo>.+?)(?:\.git)?$/,
  );

  if (!match?.groups) {
    return null;
  }

  const { owner, repo } = match.groups;
  return { owner, repo };
}

const SENTINEL_COMMENT = "# AUTOGENERATED - DO NOT EDIT BELOW THIS LINE";

async function* entriesFromFile(filename: string): AsyncGenerator<string> {
  let multiline = null;
  for await (const current of safeLinesFromFile(filename)) {
    if (multiline === null) {
      if (parseLine(current).value?.startsWith('"')) {
        multiline = current;
      } else {
        yield current;
      }
    } else {
      multiline += "\n" + current;

      if (current.endsWith('"')) {
        yield multiline;
        multiline = null;
      }
    }
  }
}

function parseLine(line: string): { key: string | null; value: string | null } {
  const trimmed = line.trim();
  if (trimmed.startsWith("#")) {
    return { key: null, value: null };
  }

  const splitIndex = trimmed.indexOf("=");
  if (splitIndex === -1) {
    return { key: null, value: null };
  }
  return {
    key: trimmed.slice(0, splitIndex),
    value: trimmed.slice(splitIndex + 1),
  };
}

async function main() {
  const repo = await getCurrentGitHubRepo();
  if (!repo) {
    console.error("No GitHub repository detected");
    Deno.exit(1);
  }

  const homeDir = Deno.env.get("HOME");
  if (!homeDir) {
    console.error("$HOME environment variable is not set");
    Deno.exit(1);
  }

  const envConfigDir = join(
    homeDir,
    ".config",
    "env",
    repo.owner,
    repo.repo,
  );
  if (!(await exists(envConfigDir))) {
    console.error(`No env files found for ${repo.owner}/${repo.repo}`);
    Deno.exit(1);
  }

  const extraFiles = [];
  for await (const entry of Deno.readDir(envConfigDir)) {
    if (!entry.isFile) {
      continue;
    }

    let name;

    // copy_$filename files are copied to the working directory
    name = stripPrefix(entry.name, "copy_");
    if (name !== null) {
      const sourcePath = join(envConfigDir, entry.name);
      await Deno.copyFile(sourcePath, name);
      console.log(`Synced ${name}`);
      extraFiles.push(name);
      continue;
    }

    // generate_$filename scripts generate files in the working directory
    name = stripPrefix(entry.name, "generate_");
    if (name !== null) {
      const generatorScript = join(envConfigDir, entry.name);
      // The script contains a "# generates $output" line that specifies the output file the script generates
      const outputFile = (await filterMap(
        linesFromFile(generatorScript),
        (line) => stripPrefix(line, "# generates "),
      ).next()).value;
      // Reuse the generated file if it exists unless we are manually regenerating generated files
      if (outputFile) {
        const cachedFile = join(envConfigDir, outputFile);
        if (
          Deno.args.includes("--regenerate") || (!(await exists(cachedFile)))
        ) {
          await $`${generatorScript} > ${$.path(cachedFile)}`;
          console.log(`Generated ${outputFile}`);
        }
        await Deno.copyFile(cachedFile, outputFile);
        extraFiles.push(outputFile);
      }
      continue;
    }
  }

  const envFile = ".env.local";
  const overrideLines = await Array.fromAsync(
    takeWhile(entriesFromFile(envFile), (line) => line !== SENTINEL_COMMENT),
  );

  const overrides = new Set<string>();
  for (const line of overrideLines) {
    const { key } = parseLine(line);
    if (key) {
      overrides.add(key);
    }
  }

  const envLines = [...overrideLines, SENTINEL_COMMENT];
  for await (
    const line of chain(
      entriesFromFile(join(envConfigDir, ".env.local")),
      entriesFromFile(join(envConfigDir, "secrets.env")),
    )
  ) {
    const { key } = parseLine(line);
    if (key && overrides.has(key)) {
      envLines.push(`# ${line.replaceAll("\n", "\n# ")}`);
    } else {
      envLines.push(line);
    }
  }

  await Deno.writeTextFile(envFile, envLines.join("\n") + "\n");
  console.log(`Synced environment variables to ${envFile}`);

  const gitDir = await $`git rev-parse --git-common-dir`.text();
  const gitExcludePath = join(gitDir, "info", "exclude");
  await $`ensure-lines ${gitExcludePath}`.stdinText(extraFiles.join("\n"));
  console.log(
    `Ignored ${extraFiles.length} file(s) in git [${extraFiles.join(", ")}]`,
  );

  if (Deno.args.includes("--new")) {
    await $`mise trust`;
    const miseTasks = await $`mise task --local`.lines();
    if (miseTasks.includes("setup")) {
      await $`mise task run setup`.noThrow();
    }
  }
}

main();
