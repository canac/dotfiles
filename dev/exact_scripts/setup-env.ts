import $ from "jsr:@david/dax@0.43.2";
import { exists } from "jsr:@std/fs@1.0.19";
import { join } from "jsr:@std/path@1.0.4";
import { chain, filterMap, takeWhile } from "./lib/iterators.ts";
import { linesFromFile, safeLinesFromFile } from "./lib/readables.ts";

function stripPrefix(input: string, prefix: string): string | null {
  return input.startsWith(prefix) ? input.slice(prefix.length) : null;
}

interface GitHubRepo {
  owner: string;
  repo: string;
}
async function getCurrentGitHubRepo(): Promise<GitHubRepo | null> {
  const remoteUrl = await $`git remote get-url origin`.text();
  const match = remoteUrl.match(
    /https:\/\/github\.com\/(?<owner>.+?)\/(?<repo>.+?)(?:\.git)?$/,
  );

  if (!match?.groups) {
    return null;
  }

  const { owner, repo } = match.groups;
  return { owner, repo };
}

const SENTINEL_COMMENT = "# AUTOGENERATED - DO NOT EDIT BELOW THIS LINE";

async function* entriesFromFile(filename: string): AsyncGenerator<string> {
  let multiline = null;
  for await (const current of safeLinesFromFile(filename)) {
    if (multiline === null) {
      if (parseLine(current).value?.startsWith('"')) {
        multiline = current;
      } else {
        yield current;
      }
    } else {
      multiline += "\n" + current;

      if (current.endsWith('"')) {
        yield multiline;
        multiline = null;
      }
    }
  }
}

function parseLine(line: string): { key: string | null; value: string | null } {
  const trimmed = line.trim();
  if (trimmed.startsWith("#")) {
    return { key: null, value: null };
  }

  const splitIndex = trimmed.indexOf("=");
  if (splitIndex === -1) {
    return { key: null, value: null };
  }
  return {
    key: trimmed.slice(0, splitIndex),
    value: trimmed.slice(splitIndex + 1),
  };
}

interface CopiedFile {
  from: string;
  to: string;
}

/**
 * Take the environment variables from the secrets files and merge them into the project's .env.local, letting the
 * project's .env.local take precedence.
 */
async function mergeEnvs(
  repoDir: string,
  secretsFiles: string[],
) {
  const envFile = ".env.local";
  const envPath = join(repoDir, envFile);
  const overrideLines = await Array.fromAsync(
    takeWhile(
      entriesFromFile(envPath),
      (line) => line !== SENTINEL_COMMENT,
    ),
  );

  const overrides = new Set<string>();
  for (const line of overrideLines) {
    const { key } = parseLine(line);
    if (key) {
      overrides.add(key);
    }
  }

  const envLines = [...overrideLines, SENTINEL_COMMENT];
  for await (
    const line of chain(
      ...secretsFiles.map((file) => entriesFromFile(file)),
    )
  ) {
    const { key } = parseLine(line);
    if (key && overrides.has(key)) {
      envLines.push(`# ${line.replaceAll("\n", "\n# ")}`);
    } else {
      envLines.push(line);
    }
  }

  await Deno.writeTextFile(envPath, envLines.join("\n") + "\n");
  console.log(`Synced environment variables to ${envFile}`);
}

/**
 * Apply all changes to a specific git repo.
 */
async function setupRepo(
  repoDir: string,
  secretsFiles: string[],
  copiedFiles: CopiedFile[],
) {
  console.group(`Setting up repo ${repoDir}`);

  for await (const { from, to } of copiedFiles) {
    console.log(`Synced ${to}`);
    await Deno.copyFile(from, join(repoDir, to));
  }

  await mergeEnvs(repoDir, secretsFiles);

  const gitDir = await $`git rev-parse --git-common-dir`.text();
  const gitExcludePath = join(gitDir, "info", "exclude");
  const ignoredFiles = [".env.local", ...copiedFiles.map((file) => file.to)];
  await $`ensure-lines ${gitExcludePath}`.stdinText(ignoredFiles.join("\n"));
  console.log(
    `Ignored ${ignoredFiles.length} file(s) in git [${
      ignoredFiles.join(", ")
    }]`,
  );

  if (Deno.args.includes("--new")) {
    await $`mise trust`;
    const miseTasks = await $`mise task --local`.lines();
    if (miseTasks.includes("setup")) {
      await $`mise task run setup`.noThrow();
    }
  }

  console.groupEnd();
}

/**
 * Run generate-cached and return the filename of the generated data.
 */
function runGenerator(generatorScript: string): Promise<string> {
  const regenerate = Deno.args.includes("--regenerate");
  return $`~/dev/scripts/generate-cached.fish ${generatorScript} ${
    regenerate ? ["--regenerate"] : []
  }`.text();
}

async function main() {
  const repo = await getCurrentGitHubRepo();
  if (!repo) {
    console.error("No GitHub repository detected");
    Deno.exit(1);
  }

  const homeDir = Deno.env.get("HOME");
  if (!homeDir) {
    console.error("$HOME environment variable is not set");
    Deno.exit(1);
  }

  const envConfigDir = join(
    homeDir,
    ".config",
    "env",
    repo.owner,
    repo.repo,
  );
  if (!(await exists(envConfigDir))) {
    console.error(`No env files found for ${repo.owner}/${repo.repo}`);
    Deno.exit(1);
  }

  const secretsFiles = [join(envConfigDir, ".env.local")];
  const copiedFiles: CopiedFile[] = [];
  for await (const entry of Deno.readDir(envConfigDir)) {
    if (!entry.isFile) {
      continue;
    }

    let name;

    // copy_$filename files are copied to the working directory
    name = stripPrefix(entry.name, "copy_");
    if (name !== null) {
      copiedFiles.push({ from: join(envConfigDir, entry.name), to: name });
      continue;
    }

    // secrets_$filename scripts generate secrets to be merged into .env.local
    name = stripPrefix(entry.name, "secrets_");
    if (name !== null) {
      const secretsFile = await runGenerator(join(envConfigDir, entry.name));
      console.log(`Generated secrets from ${name}`);
      secretsFiles.push(secretsFile);
      continue;
    }

    name = stripPrefix(entry.name, "generate_");
    if (name !== null) {
      const generatorScript = join(envConfigDir, entry.name);
      // The script contains a "# generates $output" line that specifies the output file the script generates
      const outputFile = (await filterMap(
        linesFromFile(generatorScript),
        (line) => stripPrefix(line, "# generates "),
      ).next()).value;
      if (outputFile) {
        const generatedFile = await runGenerator(generatorScript);
        console.log(`Generated ${outputFile} from ${name}`);
        copiedFiles.push({ from: generatedFile, to: outputFile });
      }
      continue;
    }
  }

  if (Deno.args.includes("--all")) {
    // Apply changes to all worktrees
    const worktrees = (await $`git worktree list --porcelain`.lines())
      .map((line) => stripPrefix(line, "worktree "))
      .filter((line) => line !== null);
    console.log(`Setting up ${worktrees.length} worktrees`);
    for await (const worktree of worktrees) {
      await setupRepo(worktree, secretsFiles, copiedFiles);
    }
  } else {
    const repo = await $`git rev-parse --show-toplevel`.text();
    await setupRepo(repo, secretsFiles, copiedFiles);
  }
}

main();
