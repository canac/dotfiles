import $ from "jsr:@david/dax@0.43.2";
import { exists } from "jsr:@std/fs@1.0.19";
import { join } from "jsr:@std/path@1.0.4";
import { TextLineStream } from "jsr:@std/streams@1.0.10";

async function* chain<T>(
  ...iterables: AsyncIterable<T>[]
): AsyncGenerator<T> {
  for (const iterable of iterables) {
    yield* iterable;
  }
}

async function* takeWhile<T>(
  iterable: AsyncIterable<T>,
  predicate: (value: T) => boolean,
): AsyncGenerator<T> {
  for await (const value of iterable) {
    if (!predicate(value)) {
      break;
    }
    yield value;
  }
}

interface GitHubRepo {
  owner: string;
  repo: string;
}
async function getCurrentGitHubRepo(): Promise<GitHubRepo | null> {
  const remoteUrl = await $`git remote get-url origin`.text();
  const match = remoteUrl.match(
    /https:\/\/github\.com\/(?<owner>.+?)\/(?<repo>.+?)(?:\.git)?$/,
  );

  if (!match?.groups) {
    return null;
  }

  const { owner, repo } = match.groups;
  return { owner, repo };
}

const SENTINEL_COMMENT = "# AUTOGENERATED - DO NOT EDIT BELOW THIS LINE";

async function* linesFromFile(filename: string): AsyncGenerator<string> {
  try {
    using file = await Deno.open(filename);
    yield* file.readable
      .pipeThrough(new TextDecoderStream())
      .pipeThrough(new TextLineStream());
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return;
    }

    throw error;
  }
}

async function* entriesFromFile(filename: string): AsyncGenerator<string> {
  let multiline = null;
  for await (const current of linesFromFile(filename)) {
    if (multiline === null) {
      if (parseLine(current).value?.startsWith('"')) {
        multiline = current;
      } else {
        yield current;
      }
    } else {
      multiline += "\n" + current;

      if (current.endsWith('"')) {
        yield multiline;
        multiline = null;
      }
    }
  }
}

function parseLine(line: string): { key: string | null; value: string | null } {
  const trimmed = line.trim();
  if (trimmed.startsWith("#")) {
    return { key: null, value: null };
  }

  const splitIndex = trimmed.indexOf("=");
  if (splitIndex === -1) {
    return { key: null, value: null };
  }
  return {
    key: trimmed.slice(0, splitIndex),
    value: trimmed.slice(splitIndex + 1),
  };
}

async function main() {
  const repo = await getCurrentGitHubRepo();
  if (!repo) {
    console.error("No GitHub repository detected");
    Deno.exit(1);
  }

  const homeDir = Deno.env.get("HOME");
  if (!homeDir) {
    console.error("$HOME environment variable is not set");
    Deno.exit(1);
  }

  const envConfigDir = join(
    homeDir,
    ".config",
    "env",
    repo.owner,
    repo.repo,
  );
  if (!(await exists(envConfigDir))) {
    console.error(`No env files found for ${repo.owner}/${repo.repo}`);
    Deno.exit(1);
  }

  const envSecretsPath = join(envConfigDir, "secrets.env");
  const getSecretsScript = join(envConfigDir, "get-secrets.sh");
  if (
    await exists(getSecretsScript) && !(await exists(envSecretsPath)) ||
    Deno.args.includes("--refresh-secrets")
  ) {
    await $`${getSecretsScript} > ${envSecretsPath}`;
  }

  const envFile = ".env.local";
  const overrideLines = await Array.fromAsync(
    takeWhile(entriesFromFile(envFile), (line) => line !== SENTINEL_COMMENT),
  );

  const overrides = new Set<string>();
  for (const line of overrideLines) {
    const { key } = parseLine(line);
    if (key) {
      overrides.add(key);
    }
  }

  const envLines = [...overrideLines, SENTINEL_COMMENT];
  for await (
    const line of chain(
      entriesFromFile(join(envConfigDir, ".env.local")),
      entriesFromFile(envSecretsPath),
    )
  ) {
    const { key } = parseLine(line);
    if (key) {
      envLines.push(
        overrides.has(key) ? `# ${line.replaceAll("\n", "\n# ")}` : line,
      );
    }
  }

  await Deno.writeTextFile(envFile, envLines.join("\n") + "\n");
  console.log(`Synced environment variables to ${envFile}`);

  const extraPrefix = "extra_";
  const extraFiles = [];
  for await (const entry of Deno.readDir(envConfigDir)) {
    if (entry.isFile && entry.name.startsWith(extraPrefix)) {
      const name = entry.name.slice(extraPrefix.length);
      const sourcePath = join(envConfigDir, entry.name);
      await Deno.copyFile(sourcePath, name);
      console.log(`Synced ${name}`);
      extraFiles.push(name);
    }
  }

  const gitExcludePath = ".git/info/exclude";
  const excludeLines = await Array.fromAsync(
    takeWhile(
      linesFromFile(gitExcludePath),
      (line) => line !== SENTINEL_COMMENT,
    ),
  );
  const gitExcludeLines = extraFiles.length > 0
    ? [...excludeLines, SENTINEL_COMMENT, ...extraFiles]
    : excludeLines;
  await Deno.writeTextFile(gitExcludePath, gitExcludeLines.join("\n") + "\n");

  if (Deno.args.includes("--new")) {
    await $`mise trust`;
    const miseTasks = await $`mise task --local`.lines();
    if (miseTasks.includes("setup")) {
      await $`mise task run setup`.noThrow();
    }
  }
}

main();
